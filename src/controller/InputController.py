# CS 386# Introduction to Game Design and Production# Assignment 6: Final Game Project# by Marcel Schnelle# mschnelle@csu.fullerton.edufrom src.constants import STATE_MAIN_MENU, STATE_GAME_RUNNING, \    STATE_GAME_INVENTORY, KEYS_CHARACTERS, KEYS_NUMBERS, KEYS_DELETE, KEYS_MOVEMENT, \    CURRENTLY_PAUSING_FOR_CLICK, CUTSCENE_RUNNING, STATE_GAME_MENUfrom src.interfaces import Listenerfrom src.model.EventTypes import GameStateChangedEvent, QuitEvent, TickEvent, \    MouseMotionEvent, MouseClickEvent, NewGameToggleEvent, CharAddEvent, \    CharDelEvent, CharEnteringCompleteEvent, InventoryToggleEvent, SaveEvent, \    MovementDoneEvent, MovementRequestEvent, GameMenuToggleEvent, \    FullscreenToggleRequestEventfrom src.utilities import force_number, get_property, set_propertyimport pygame# InputController.# This class provides the interface to the user's input devices like mouse and keyboard.# Its only instance is connected to the central Event Manager and notifies other listeners# of input events that ocurred throughout the application's runtime. While it does not know# the current meaning of each individual keystroke or mouse movement, it has got a set# of input handlers that may be switched out on request. These input handlers have a better# understanding about how to react to pygame events and thus, their main task is to post# different types of events to the listener pool according to pressed or released keys.# Implements:#   Listenerclass InputController(Listener):    # Initialize the input controller and set the event manager reference    # Parameter:    #   evManager   :   Event Manager    def __init__(self, evManager):        Listener.__init__(self, evManager)        self.handler = None        self.state = None            # Listener interface implementation    # Parameter:    #   event   :   The event that the event manager has received    def notify(self, event):        # If it is a game state change event, the input controller changes its event handler        if isinstance(event, GameStateChangedEvent):            self.changeHandler(event.object)        # Else, the designated handler deals with the event        else:            self.handler.handle(event)                            # Handler change method. Any time the input controller is notified of a game state change event,    # this method changes the controller's handler reference. For example, the main menu    # handler, unlike the game handler, does not process key events at all because it is not    # necessary.    # Parameter:    #   state   :   The new state to which the handler is going to be set    def changeHandler(self, state):        self.state = state        if state == STATE_MAIN_MENU:            self.handler = MainMenuInputHandler(self)        elif state == STATE_GAME_RUNNING:            self.handler = GameInputHandler(self)        elif state in [STATE_GAME_INVENTORY, STATE_GAME_MENU]:            self.handler = GameMenuOrInventoryInputHandler(self)                # Convenience method to post a QuitEvent when one of the handlers encounters a game-quitting action    def quit(self):        self.evManager.post(QuitEvent())# Base class for Input Handler objects. Basically does nothing itself, but instead defines the method interface for subclassesclass InputHandler:    # Constructor.    # Parameter:    #   ih  :   Reference to the input controller.    #           This way, a handler may access the event manager to post events to    def __init__(self, ih):        self.ih = ih            # Method handle interface. Does nothing.    def handle(self, event):        pass        def handleFullscreenToggling(self, event):        if event.key == pygame.K_RETURN and event.mod&(pygame.KMOD_LALT|pygame.KMOD_RALT) != 0:            self.ih.evManager.post(FullscreenToggleRequestEvent())        # Input handler for the main menu screen. It is derived from the Input Handler base class.class MainMenuInputHandler(InputHandler):    # Constructor.    # Parameter:    #   ih  :   Reference to the input controller.    #           This way, a handler may access the event manager to post events to    def __init__(self, ih):        InputHandler.__init__(self, ih)        self.newgame_open = False            # Handle method implementation.    # Parameter:    #   event   :   The event that has been passed to handle    def handle(self, event):        # TickEvent: Handle pygame input        if isinstance(event, TickEvent):            for event in pygame.event.get():                # Quit event registered by closing the window, for example                if event.type == pygame.QUIT:                    self.ih.quit()                # Keydown event: If the user has pressed a key                elif event.type == pygame.KEYDOWN:                    self.handleFullscreenToggling(event)                    if self.newgame_open:                        # Do some extra handling when the new game menu is open.                        # (Save game name entering screen...)                        self.handleNewGameInput(event)                    # Quit event whenever escape is pressed in the main menu                    if event.key == pygame.K_ESCAPE:                            self.ih.quit()                # Mouse motion event                elif event.type == pygame.MOUSEMOTION:                    # Simply post the recognized mouse motion to the event manager                    self.ih.evManager.post(MouseMotionEvent(event))                # Mouse click event                elif event.type == pygame.MOUSEBUTTONDOWN:                    # Post the recognized event to the event manager                    self.ih.evManager.post(MouseClickEvent(event))        # NewGameToggleEvent: Toggle the menu display of the "new game dialog"        elif isinstance(event, NewGameToggleEvent):            # Flip the switch            self.newgame_open = not self.newgame_open            # Handle the input of any key during the name entering screen.    # This method fires both CharAddEvents and CharDelEvents to the view controller,    # who then constructs the save game name to be used.    # Parameter:    #   event   :   The KEYDOWN event sent by pygame    def handleNewGameInput(self, event):        if event.key in KEYS_CHARACTERS:            self.ih.evManager.post(CharAddEvent(chr(event.key)))        elif event.key in KEYS_NUMBERS:            key_code = chr(event.key)            if event.mod == pygame.KMOD_LSHIFT:                # Force numbers, therefore when shift is pressed                # and e.g. a "1" is changed to a "!", force it back                key_code = force_number(key_code)            self.ih.evManager.post(CharAddEvent(key_code))        elif event.key in KEYS_DELETE:            self.ih.evManager.post(CharDelEvent())        elif event.key == pygame.K_RETURN:            self.ih.evManager.post(CharEnteringCompleteEvent())    # Input handler for the game screen. It is derived from the input handler base class.class GameInputHandler(InputHandler):    # Constructor.    # Parameter:    #   ih  :   Reference to the input controller.    #           This way, a handler may access the event manager to post events to    def __init__(self, ih):        InputHandler.__init__(self, ih)        self.pressed = []            # Handle method implementation.    # Parameter:    #   event   :   The event that has been passed to handle    def handle(self, event):        # TickEvent: Handle input        if isinstance(event, TickEvent):            for event in pygame.event.get():                # Quit event registered by closing the window, for example                if event.type == pygame.QUIT:                    self.ih.quit()                # Keydown event, if the user has pressed a key                elif event.type == pygame.KEYDOWN:                    self.handleFullscreenToggling(event)                    # Trigger main menu toggle                    if event.key == pygame.K_ESCAPE:                        self.ih.evManager.post(GameMenuToggleEvent())                    # Movement keys                    elif event.key in KEYS_MOVEMENT:                        # Add this key to the list of pressed keys and post a MovementRequestEvent                        self.pressed.append(event.key)                        self.postMovementRequest()                    # Inventory open/close                    elif event.key == pygame.K_TAB:                        self.ih.evManager.post(InventoryToggleEvent())                    # Quick save                    elif event.key == pygame.K_F5:                        self.ih.evManager.post(SaveEvent())                # Keyup event, if the user has released a key                elif event.type == pygame.KEYUP:                    if event.key in KEYS_MOVEMENT:                        # Delete this key from the list of pressed keys                        if event.key in self.pressed:                            self.pressed.remove(event.key)                        # If, now, there is no key pressed at all, post a MovementDoneEvent                        if len(self.pressed) == 0:                            self.ih.evManager.post(MovementDoneEvent())                        # Else, the user still presses some buttons. MovementRequestEvent                        else:                            self.postMovementRequest()                # Mouse motion event                elif event.type == pygame.MOUSEMOTION:                    self.ih.evManager.post(MouseMotionEvent(event))                # Mouse click event                elif event.type == pygame.MOUSEBUTTONDOWN:                    # Extra behaviour: If the global property                    # "Currently pausing for Click" is activated,                    # a script is currently waiting for a MouseClickEvent.                    # This command seems kind of weird, since all it does is change                    # the Wait flag back if it's on.                    # (See interfaces._pauseUntilClick()                    # for the code dependent on this flag)                    if get_property(CURRENTLY_PAUSING_FOR_CLICK):                        set_property(CURRENTLY_PAUSING_FOR_CLICK, False)                    # Extra behaviour: If the global property                    # "Currently in a Cutscene" is activated,                    # the mouse click is useless and mustn't interfere                    # with the cutscene's execution.                    elif get_property(CUTSCENE_RUNNING):                        return                    else:                        # Notify the game object                        self.ih.evManager.post(MouseClickEvent(event))    # Convenience method that posts a movement request event to the event manager    # after calculating the desired destination of the movement.    def postMovementRequest(self):        keys = pygame.key.get_pressed()        direction_x = keys[pygame.K_d] - keys[pygame.K_a]        direction_y = keys[pygame.K_s] - keys[pygame.K_w]        self.ih.evManager.post(MovementRequestEvent([direction_x, direction_y]))        # Input handler for the inventory screen. It is derived from the input handler base class.class GameMenuOrInventoryInputHandler(InputHandler):    # Constructor.    # Parameter:    #   ih  :   Reference to the input controller.    #           This way, a handler may access the event manager to post events to    def __init__(self, ih):        InputHandler.__init__(self, ih)            # Handle method implementation.    # Parameter:    #   event   :   The event that has been passed to handle    def handle(self, event):        # TickEvent: Handle input        if isinstance(event, TickEvent):            for event in pygame.event.get():                # Quit event registered by closing the window, for example                if event.type == pygame.QUIT:                    self.ih.quit()                # Keydown event, if the user has pressed a key                elif event.type == pygame.KEYDOWN:                    self.handleFullscreenToggling(event)                    if event.key == pygame.K_ESCAPE:                        if self.ih.state == STATE_GAME_MENU:                            self.ih.evManager.post(GameMenuToggleEvent())                        elif self.ih.state == STATE_GAME_INVENTORY:                            self.ih.evManager.post(InventoryToggleEvent())                    # Inventory open/close                    elif event.key == pygame.K_TAB:                        if self.ih.state == STATE_GAME_INVENTORY:                            self.ih.evManager.post(InventoryToggleEvent())                # Mouse motion event                elif event.type == pygame.MOUSEMOTION:                    self.ih.evManager.post(MouseMotionEvent(event))                # Mouse click event                elif event.type == pygame.MOUSEBUTTONDOWN:                    self.ih.evManager.post(MouseClickEvent(event))